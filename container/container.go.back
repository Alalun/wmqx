package container

import (
	"github.com/spf13/viper"
	"github.com/spf13/pflag"
	"flag"
	"fmt"
	"os"
	"strings"
	"github.com/fatih/color"
	"rmqc/mq"
	"rmqc/pools"
	"errors"
)

var (
	Ctx = NewContainer()
)

type Container struct {
	Config *viper.Viper
	QMessage *mq.QMessage
	RabbitMQPools *pools.RabbitMQ
	ConsumerWorkChan chan ConsumerWorker
}

type ConsumerWorker struct {
	Action string
	QueueName string
}

// return container object
func NewContainer() *Container {
	ct := &Container{
		Config: viper.New(),
		QMessage: mq.NewQMessage(),
		RabbitMQPools: pools.NewRabbitMQPools(),
		ConsumerWorkChan: make(chan ConsumerWorker, 1),
	}
	return ct
}

// init RabbitMQ pools
func (container *Container) InitRabbitMQPools() {
	container.RabbitMQPools.Init(20)
}

// init RabbitMQ all exchanges
func (container *Container) InitExchanges() error {
	rabbitMq, err := container.RabbitMQPools.GetMQ()
	if err != nil {
		return errors.New("rabbitmq pools faild: " + err.Error())
	}
	defer container.RabbitMQPools.Recover(rabbitMq)

	container.QMessage.Lock.Lock()
	defer container.QMessage.Lock.Unlock()

	messages := container.QMessage.Messages
	for _, message := range messages {
		// declare exchange
		err := rabbitMq.DeclareExchange(message.Name, message.Mode, message.Durable)
		if err != nil {
			return errors.New("Declare exchange faild: "+err.Error())
		}
		// declare queue
		for _, consumer := range message.Consumers {
			consumerKey := message.Name +"-"+ consumer.ID
			err := rabbitMq.DeclareQueue(consumerKey, message.Durable)
			if err != nil {
				return errors.New("Declare queue faild: "+err.Error())
			}
			// bind queue to exchange
			err = rabbitMq.BindQueueToExchange(consumerKey, message.Name, consumer.RouteKey)
			if err != nil {
				return errors.New("bind queue exchange fail: "+err.Error())
			}

			container.SendConsumerSign("insert", consumerKey)
		}
	}
	return nil
}

// declare a Exchange
func (container *Container) DeclareExchange(name string) error {
	rabbitMq, err := container.RabbitMQPools.GetMQ()
	if err != nil {
		return errors.New("rabbitmq pools faild: " + err.Error())
	}
	defer container.RabbitMQPools.Recover(rabbitMq)

	message, err := container.QMessage.GetMessageByName(name)
	if err != nil {
		return err
	}
	// declare exchange
	err = rabbitMq.DeclareExchange(message.Name, message.Mode, message.Durable)
	if err != nil {
		return errors.New("Declare exchange "+message.Name+" faild: "+err.Error())
	}

	return nil
}

// delete a exchange
func (container *Container) DeleteExchange(name string) error {
	rabbitMq, err := container.RabbitMQPools.GetMQ()
	if err != nil {
		return errors.New("rabbitmq pools faild: " + err.Error())
	}
	defer container.RabbitMQPools.Recover(rabbitMq)

	consumers := container.QMessage.GetConsumersByMessageName(name)
	if len(consumers) > 0 {
		//unbind queue exchange
		for _, consumer := range consumers {
			consumerKey := name+"-"+consumer.ID
			routeKey := consumer.RouteKey
			err := rabbitMq.UnBindQueueToExchange(consumerKey, name, routeKey)
			if err != nil {
				return errors.New("Unbind exchange "+name+" consumer id "+consumer.ID+" faild: "+err.Error())
			}
		}
	}
	// delete exchange
	err = rabbitMq.DeleteExchange(name)
	if err != nil {
		return errors.New("Delete exchange "+name+" faild: "+err.Error())
	}

	return nil
}

// declare a consumer
func (container *Container) DeclareConsumer(name string, consumerId string) error {
	rabbitMq, err := container.RabbitMQPools.GetMQ()
	if err != nil {
		return errors.New("rabbitmq pools faild: " + err.Error())
	}
	defer container.RabbitMQPools.Recover(rabbitMq)

	message, err := container.QMessage.GetMessageByName(name)
	if err != nil {
		return err
	}
	consumer, err := container.QMessage.GetConsumerById(name, consumerId)
	if err != nil {
		return err
	}
	consumerKey := message.Name +"-"+ consumer.ID
	// declare queue
	err = rabbitMq.DeclareQueue(consumerKey, message.Durable)
	if err != nil {
		return errors.New("Declare queue faild: "+err.Error())
	}
	// bind queue to exchange
	err = rabbitMq.BindQueueToExchange(consumerKey, message.Name, consumer.RouteKey)
	if err != nil {
		return errors.New("bind queue exchange fail: "+err.Error())
	}

	return nil
}

// init consumer
func (container *Container) InitConsumer() {

	go func() {
		consumerWorker := <- container.ConsumerWorkChan

		switch consumerWorker.Action {
		case "insert":
			go func() {
				rabbitMq, _ := container.RabbitMQPools.GetMQ()
				defer container.RabbitMQPools.Recover(rabbitMq)
				channel, _ := rabbitMq.Conn.Channel()
				defer channel.Close()

				autoAck := false // is auto ack
				exclusive := false //
				noLocal := false
				noWait := false
				delivery, _ := channel.Consume(consumerWorker.QueueName, "", autoAck, exclusive, noLocal, noWait, nil)
				for {
					select {
					case d := <-delivery:
						file, _ := os.OpenFile("./consumer.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0766)
						file.WriteString(string(d.Body) + "\r\n")
						file.Close()
						d.Ack(true)
					//d.Nack(false, true)
					}
				}
			}()
		case "update":
			return
		case "delete":
			return
		case "status":
			return
		}
	}()
}

// publish message to mq
func (container *Container) Publish(body string, exchangeName string, token string, routeKey string) (err error) {
	qMessage, err := container.QMessage.GetMessageByName(exchangeName)
	if err != nil {
		return
	}
	if qMessage.IsNeedToken && qMessage.Token != token {
		return errors.New("token error")
	}

	rabbitMq, err := container.RabbitMQPools.GetMQ()
	if err != nil {
		return errors.New("rabbitmq pools faild: "+err.Error())
	}
	defer container.RabbitMQPools.Recover(rabbitMq)

	return rabbitMq.Publish(exchangeName, routeKey, body)
}

// send consumer sign
func (container *Container) SendConsumerSign(action string, consumerKey string) {
	container.ConsumerWorkChan <- ConsumerWorker{
		Action: action,
		QueueName: consumerKey,
	}
}

func printExample() {
	fmt.Println(`[{
    "Comment": "",
    "Consumers": [{
            "Comment": "",
            "ID": "111",
            "Code": 200,
            "CheckCode": true,
            "RouteKey": "#",
            "Timeout": 5000,
            "URL": "http://test.com/wmq.php"
        }
    ],
    "Durable": false,
    "IsNeedToken": true,
    "Mode": "topic",
    "Name": "test",
    "Token": "JQJsUOqYzYZZgn8gUvs7sIinrJ0tDD8J"
}]`)
}

func poster() string {
	fg := color.New(color.FgHiYellow).SprintFunc()
	return fg(`
██╗    ██╗███╗   ███╗ ██████╗
██║    ██║████╗ ████║██╔═══██╗
██║ █╗ ██║██╔████╔██║██║   ██║
██║███╗██║██║╚██╔╝██║██║▄▄ ██║
╚███╔███╔╝██║ ╚═╝ ██║╚██████╔╝
 ╚══╝╚══╝ ╚═╝     ╚═╝ ╚══▀▀═╝
Author: snail
Link  : https://github.com/snail007/wmq
`)
}